tiny	2	0	spigot	mojang+yarn

# Originally DistanceManager, which also implements DistanceManager, so clashes since the implemented class
# is imported and not fully qualified. Easiest fix is to just change the name
c	net/minecraft/server/PlayerChunkMap$a	net/minecraft/server/level/ChunkMap$ChunkDistanceManager

# CraftBukkit adds the getServer() method, clashes with a Mojang method
c	net/minecraft/server/World	net/minecraft/world/level/Level
	m	()Lorg/bukkit/craftbukkit/CraftServer;	getServer	getCraftServer

# CraftBukkit adds the server field, clashes with a Mojang field
c	net/minecraft/server/PlayerConnection	net/minecraft/server/network/ServerGamePacketListenerImpl
	f	Lorg/bukkit/craftbukkit/CraftServer;	server	craftServer

# CraftBukkit adds the player field, clashes with a Mojang field
c	net/minecraft/server/ContainerWorkbench	net/minecraft/world/inventory/CraftingMenu
	f	Lnet/minecraft/server/PlayerInventory;	player	playerInventory

# CraftBukkit adds the getType() method, clashes with a Mojang method
c	net/minecraft/server/EntityAreaEffectCloud	net/minecraft/world/entity/AreaEffectCloud
	m	()Ljava/lang/String;	getType	getTypeCb

# CraftBukkit adds the getType() method, clashes with a Mojang method
c	net/minecraft/server/EntityTippedArrow	net/minecraft/world/entity/projectile/Arrow
	m	()Ljava/lang/String;	getType	getTypeCb

# CraftBukkit adds the getLevel() method, clashes with original method
c	net/minecraft/server/TileEntityBeacon	net/minecraft/world/level/block/entity/BeaconBlockEntity
	m	()I	getLevel	getLevelCb

# CraftBukkit maps all of:
#     Merchant.getLevel()
#     Hopper.getLevel()
#     Entity.getCommandSenderWorld()
# to getWorld(), which confuses our ability to map this method properly. This patch disambiguates it
#c	net/minecraft/server/EntityMinecartHopper	net/minecraft/world/entity/vehicle/MinecartHopper
#	m	()Lnet/minecraft/server/World;	getWorld	getLevel
#c	net/minecraft/server/EntityVillagerAbstract	net/minecraft/world/entity/npc/AbstractVillager
#	m	()Lnet/minecraft/server/World;	getWorld	getLevel

# CraftBukkit adds the getLootTable() method, clashes with original method
c	net/minecraft/server/EntityInsentient	net/minecraft/world/entity/Mob
	m	()Lnet/minecraft/server/MinecraftKey;	getLootTable	getLootTableCb

# CraftBukkit adds the canCollideWith() method, clashes with original method
c	net/minecraft/server/Entity	net/minecraft/world/entity/Entity
	m	(Lnet/minecraft/server/Entity;)Z	canCollideWith	canCollideWithCb

# CraftBukkit adds a new `a` method which allows passing the Entity parameter
# It uses `a` to match the original method (with just 1 param), so this patch makes them match
c	net/minecraft/server/WorldServer	net/minecraft/server/level/ServerLevel
	m	(Lnet/minecraft/server/WorldServer;Lnet/minecraft/server/Entity;)V	a	makeObsidianPlatform

# CraftBukkit adds `getMinecraftWorld()` to `GeneratorAccess`, which matches `WorldAccess.getMinecraftWorld()`
# But that method in `WorldAccess` is called `getLevel()` in Mojang mappings
c	net/minecraft/server/GeneratorAccess	net/minecraft/world/level/LevelAccessor
	m	()Lnet/minecraft/server/WorldServer;	getMinecraftWorld	getLevel

# SpecialSource2 automatically maps methods to the name of synthetic methods that point to it in an attempt to
# normalize method names with what is expected by the super class. This is _extremely_ stupid and flawed however
# because synthetic methods by definition have different descriptors than the base method, which means method
# signature clashes become possible, which is what happens here.
#
# LootEntryAbstract$Serializer has a synthetic method pointing to the base serialize() method with the following descriptor:
#
#    (JsonObject,Object,JsonSerializationContext)V  <-- ProGuard names this method `a`
#
# and this synthetic method points to another method with the specialized descriptor:
#
#    (JsonObject,LootEntryAbstract,JsonSerializationContext)V  <-- ProGuard names this method `b`
#
# SpecialSource2 automatically maps the second method name to the name of the first method, in this case `a`.
#
# LootEntryAbstract$Serializer also has another method with the same descriptor as serialize(), which Spigot calls
# serializeCustom(). Of course ProGuard strips the names and since this method is the first time it's seen this
# descriptor, it renamed that method also to `a`.
#
# This is allowed because the synthetic method for serialize() has a different descriptor, using Object as the second
# parameter. This breaks when SpecialSource2 does it's "magic" of course. This patch manually fixes this case by adding
# both correct mappings
c	net/minecraft/server/LootEntryAbstract$Serializer	net/minecraft/world/level/storage/loot/entries/LootPoolEntryContainer$Serializer
	m	(Lcom/google/gson/JsonObject;Lnet/minecraft/server/LootEntryAbstract;Lcom/google/gson/JsonSerializationContext;)V	a	serialize
		p	0		json
		p	1		entry
		p	2		context
	m	(Lcom/google/gson/JsonObject;Lnet/minecraft/server/LootEntryAbstract;Lcom/google/gson/JsonSerializationContext;)V	serializeType	serializeCustom

# TODO figure out what's going on here
#c	net/minecraft/server/EntityInsentient	net/minecraft/world/entity/Mob
#	m	(Lnet/minecraft/server/EntityHuman;Lnet/minecraft/server/EntityInsentient;)V	a	onOffspringSpawnedFromEgg
